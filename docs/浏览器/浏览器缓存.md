### 浏览器获取缓存的流程为:

1. 先根据这个资源的一些 http header 判断它是否命中强缓存，如果命中，则直接从本地获取缓存资源，不会发请求到服务器；
2. 当强缓存没有命中时，客户端会发送请求到服务器，服务器通过另一些 request header 验证这个资源是否命中协商缓存，称为 http 再验证，如果命中，服务器将请求返回，但不返回资源，而是告诉客户端直接从缓存中获取，客户端收到返回后就会从缓存中获取资源；
3. 强缓存和协商缓存共同之处在于，如果命中缓存，服务器都不会返回资源；区别是，强缓存不对发送请求到服务器，但协商缓存会。

当协商缓存也没命中时，服务器就会将资源发送回客户端。

当 ctrl+f5 强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；

当 f5 刷新网页时，跳过强缓存，但是会检查协商缓存。

### 缓存的位置

- Service Worker

使用 Service Worker 时，传输必须是 HTTPS 协议，因为它涉及到了请求拦截。

Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。

当 Service Worker 没有命中缓存的时候，我们需要去调用 fetch 函数获取数据。也就是说，如果我们没有在 Service Worker 命中缓存的话，会根据缓存查找优先级去查找数据。但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容。

- Memory Cache

一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。

内存缓存在缓存资源时并不关心返回资源的 HTTP 缓存头 Cache-Control 是什么值，同时资源的匹配也并非仅仅是对 URL 做匹配，还可能会对 Content-Type，CORS 等其他特征做校验。

- Disk Cache

它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。

- Push Cache

Push Cache（推送缓存）是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂，在 Chrome 浏览器中只有 5 分钟左右，同时它也并非严格执行 HTTP 头中的缓存指令。

所有的资源都能被推送，并且能够被缓存,但是 Edge 和 Safari 浏览器支持相对比较差

可以推送 no-cache 和 no-store 的资源

一旦连接被关闭，Push Cache 就被释放

多个页面可以使用同一个 HTTP/2 的连接，也就可以使用同一个 Push Cache。这主要还是依赖浏览器的实现而定，出于对性能的考虑，有的浏览器会对相同域名但不同的 tab 标签使用同一个 HTTP 连接。

Push Cache 中的缓存只能被使用一次

浏览器可以拒绝接受已经存在的资源推送

可以给其他域名推送资源

### 强缓存相关的字段

- Expires

该字段是 `http1.0` 时的规范，值为一个绝对时间的 GMT 格式的时间字符串，代表缓存资源的过期时间

- Cache-Control

该字段是 `http1.1`的规范，强缓存利用其 max-age 值来判断缓存资源的最大生命周期，它的值单位为秒

常用的指令有:

1. **no-cache**:不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在 ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。
2. **no-store**:直接禁止游览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。
3. **public**:可以被所有的用户缓存，包括终端用户和 CDN 等中间代理服务器。
4. **private**:只能被终端用户的浏览器缓存，不允许 CDN 等中继缓存服务器对其缓存。
5. **max-age**:指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应。
6. **s-maxage**：同 max-age 作用一样，只在代理服务器中生效（比如 CDN 缓存）。
7. **max-stale**: 能容忍的最大过期时间。max-stale 指令标示了客户端愿意接收一个已经过期了的响应。如果指定了 max-stale 的值，则最大容忍时间为对应的秒数。如果没有指定，那么说明浏览器愿意接收任何 age 的响应（age 表示响应由源站生成或确认的时间与当前时间的差值）。
8. **min-fresh**: 能够容忍的最小新鲜度。min-fresh 标示了客户端不愿意接受新鲜度不多于当前的 age 加上 min-fresh 设定的时间之和的响应。

- Pragma

Pragma 只有一个属性值，即 no-cache,效果和 Cache-Control 中的 no-cache 一致,不使用强缓存，需要与服务器验证缓存是否新鲜，在 3 个头部属性中的优先级最高。

Expires 是一个绝对时间，表示到达该时间时缓存过期，与用户本地的时间有关系，而本地时间是可以改的，会产生与服务器生成的过期时间不一致问题；

Cache-Control 表示的是一个相对时间，指从当前时间后的 max-age 时缓存过期。当这两者同时存在时，Cache-Control 的优先级更高。

### 协商缓存相关的字段

- Last-Modified

值为资源最后更新时间，随服务器 response 返回，即使文件改回去，日期也会变化

- If-Modified-Since

通过比较两个时间来判断资源在两次请求期间是否有过修改，如果没有修改，则命中协商缓存

- ETag

表示资源内容的唯一标识，随服务器 response 返回，仅根据文件内容是否变化判断

- If-None-Match

服务器通过比较请求头部的 If-None-Match 与当前资源的 ETag 是否一致来判断资源是否在两次请求之间有过修改，如果没有修改，则命中协商缓存

通常是 Last-Modified/If-Modified-Since 和 ETag/If-None-Match 配套使用。

### 缓存场景

对于某些不需要缓存的资源，可以使用 Cache-control: no-store ，表示该资源不需要缓存

对于频繁变动的资源，可以使用 Cache-Control: no-cache 并配合 ETag 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新

对于代码文件来说，通常使用 Cache-Control: max-age=31536000 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件
